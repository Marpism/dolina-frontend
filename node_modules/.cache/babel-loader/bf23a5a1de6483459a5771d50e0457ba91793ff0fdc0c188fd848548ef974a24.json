{"ast":null,"code":"import t, { useContext as e, useState as n, useRef as o, useEffect as s } from \"react\";\nfunction r() {\n  return r = Object.assign ? Object.assign.bind() : function (t) {\n    for (var e = 1; e < arguments.length; e++) {\n      var n = arguments[e];\n      for (var o in n) Object.prototype.hasOwnProperty.call(n, o) && (t[o] = n[o]);\n    }\n    return t;\n  }, r.apply(this, arguments);\n}\nconst a = (t, e) => {\n    const n = {};\n    for (const o in t) -1 === e.indexOf(o) && (n[o] = t[o]);\n    return n;\n  },\n  i = /*#__PURE__*/t.createContext(null),\n  c = /*#__PURE__*/t.createContext(null),\n  l = e => n => /*#__PURE__*/t.createElement(c.Consumer, null, o => /*#__PURE__*/t.createElement(e, r({\n    parent: o\n  }, n))),\n  p = (t = []) => {\n    const [r, a] = n(!1),\n      c = o(t),\n      l = (() => {\n        const t = e(i);\n        if (null === t) throw new Error(\"Couldn't find Yandex.Maps API in the context. Make sure that hook useYMaps is inside <YMaps /> provider\");\n        return t;\n      })(),\n      p = l.getApi();\n    return s(() => {\n      l.load().then(() => Promise.all(c.current.map(l.loadModule))).then(() => a(!0));\n    }, []), r && p ? p : null;\n  },\n  u = () => {},\n  m = [\"onLoad\", \"onError\", \"modules\", \"apiLoader\"];\nfunction d(e, n = !1, o = []) {\n  return i => {\n    const {\n        width: c,\n        height: l,\n        modules: d = [],\n        onLoad: h = u\n      } = i,\n      f = p(o.concat(d)),\n      y = !n || !!f,\n      b = a(i, m);\n    return s(() => f ? h(f) : void 0, [f]), y ? /*#__PURE__*/t.createElement(e, r({\n      ymaps: f\n    }, b)) : /*#__PURE__*/t.createElement(\"div\", {\n      style: {\n        width: c,\n        height: l\n      }\n    });\n  };\n}\nconst h = \"undefined\" != typeof window,\n  f = {\n    lang: \"ru_RU\",\n    load: \"\",\n    ns: \"\",\n    mode: \"release\"\n  },\n  y = e => {\n    const {\n        version: n = \"2.1\",\n        enterprise: r = !1,\n        query: a = {\n          lang: \"ru_RU\",\n          load: \"\",\n          ns: \"\"\n        },\n        preload: c = !1,\n        children: l\n      } = e,\n      p = o((t => {\n        const {\n            query: e = f\n          } = t,\n          n = Date.now().toString(32),\n          o = e.ns || \"\",\n          s = \"__yandex-maps-api-onload__$$\" + n,\n          r = \"__yandex-maps-api-onerror__$$\" + n,\n          a = h ? window : {},\n          i = {};\n        let c;\n        const l = () => o ? a[o] : c,\n          p = () => {\n            delete a[s], delete a[r];\n          };\n        return {\n          load: () => {\n            if (l()) return Promise.resolve(c);\n            if (i[o]) return i[o];\n            const n = {\n                onload: s,\n                onerror: r,\n                ...f,\n                ...e\n              },\n              u = Object.keys(n).map(t => `${t}=${n[t]}`).join(\"&\"),\n              m = [`https://${t.enterprise ? \"enterprise.\" : \"\"}api-maps.yandex.ru`, t.version, \"?\" + u].join(\"/\");\n            return i[o] = new Promise((t, e) => {\n              a[s] = e => {\n                p(), e.ready(() => {\n                  c = e, t(e);\n                });\n              }, a[r] = t => {\n                p(), e(t);\n              }, (t => new Promise((e, n) => {\n                const o = document.createElement(\"script\");\n                o.type = \"text/javascript\", o.onload = e, o.onerror = n, o.src = t, o.async = !0, document.head.appendChild(o);\n              }))(m).catch(a[r]);\n            }), i[o];\n          },\n          getApi: l,\n          loadModule: t => new Promise((e, n) => {\n            c.modules.require(t).done(n => {\n              n.forEach(e => {\n                ((t, e, n, o = !1) => {\n                  const s = \"string\" == typeof e ? e.split(\".\") : e.slice();\n                  let r,\n                    a = t;\n                  for (; s.length > 1;) r = s.shift(), a[r] || (a[r] = {}), a = a[r];\n                  const i = s[0];\n                  a[i] = !0 === o && a[i] || n;\n                })(c, t, e, !0);\n              }), e(c);\n            }, n);\n          })\n        };\n      })({\n        version: n,\n        enterprise: r,\n        query: a,\n        preload: c\n      }));\n    return s(() => {\n      c && p.current.load();\n    }, [p.current]), /*#__PURE__*/t.createElement(i.Provider, {\n      value: p.current\n    }, l);\n  },\n  b = /^on(?=[A-Z])/;\nfunction v(t) {\n  return Object.keys(t).reduce((e, n) => {\n    if (b.test(n)) {\n      const o = n.replace(b, \"\").toLowerCase();\n      e._events[o] = t[n];\n    } else e[n] = t[n];\n    return e;\n  }, {\n    _events: {}\n  });\n}\nfunction j(t, e, n) {\n  \"function\" == typeof n && t.events.add(e, n);\n}\nfunction O(t, e, n) {\n  \"function\" == typeof n && t.events.remove(e, n);\n}\nfunction g(t, e, n) {\n  Object.keys(Object.assign({}, e, n)).forEach(o => {\n    e[o] !== n[o] && (O(t, o, e[o]), j(t, o, n[o]));\n  });\n}\nconst E = t => \"default\" + t.charAt(0).toUpperCase() + t.slice(1);\nfunction C(t, e) {\n  return void 0 !== t[e] || void 0 === t[E(e)];\n}\nfunction _(t, e, n) {\n  return (C(t, e) ? t[e] : t[E(e)]) || n;\n}\nfunction R(t, e, n = null) {\n  if (t !== e) {\n    if (t && (\"current\" in t ? t.current = null : \"function\" == typeof t && t(null)), !e) return;\n    \"current\" in e ? e.current = n : \"function\" == typeof e && e(n);\n  }\n}\nfunction w(t) {\n  const {\n    width: e,\n    height: n,\n    style: o,\n    className: s\n  } = t;\n  return void 0 !== o || void 0 !== s ? Object.assign({}, o && {\n    style: o\n  }, s && {\n    className: s\n  }) : {\n    style: {\n      width: e,\n      height: n\n    }\n  };\n}\nclass P extends t.Component {\n  constructor(t) {\n    super(t), this.state = {\n      error: null,\n      errorInfo: null\n    };\n  }\n  componentDidCatch(t, e) {\n    const {\n      onError: n = () => {}\n    } = this.props;\n    n(t), this.setState({\n      error: t,\n      errorInfo: e\n    });\n  }\n  render() {\n    return this.state.error ? null : this.props.children;\n  }\n}\nconst x = e => ({\n  onError: n,\n  ...o\n}) => /*#__PURE__*/t.createElement(P, {\n  onError: n\n}, /*#__PURE__*/t.createElement(e, o));\nclass M extends t.Component {\n  constructor() {\n    super(), this.instance = null, this.state = {\n      instance: null\n    }, this._parentElement = null, this._getRef = t => {\n      this._parentElement = t;\n    };\n  }\n  componentDidMount() {\n    this.instance = M.mountObject(this._parentElement, this.props.ymaps.Map, this.props), this.setState({\n      instance: this.instance\n    });\n  }\n  componentDidUpdate(t) {\n    null !== this.instance && M.updateObject(this.instance, t, this.props);\n  }\n  componentWillUnmount() {\n    M.unmountObject(this.instance, this.props);\n  }\n  render() {\n    const e = w(this.props),\n      n = v(this.props),\n      o = a(n, [\"_events\", \"state\", \"defaultState\", \"options\", \"defaultOptions\", \"instanceRef\", \"ymaps\", \"children\", \"width\", \"height\", \"style\", \"className\"]); /*#__PURE__*/\n    return t.createElement(c.Provider, {\n      value: this.state.instance\n    }, /*#__PURE__*/t.createElement(\"div\", r({\n      ref: this._getRef\n    }, e, o), this.props.children));\n  }\n  static mountObject(t, e, n) {\n    const {\n        instanceRef: o,\n        _events: s\n      } = v(n),\n      r = new e(t, _(n, \"state\"), _(n, \"options\"));\n    return Object.keys(s).forEach(t => j(r, t, s[t])), R(null, o, r), r;\n  }\n  static updateObject(t, e, n) {\n    const {\n        _events: o,\n        instanceRef: s\n      } = v(n),\n      {\n        _events: r,\n        instanceRef: a\n      } = v(e);\n    if (C(n, \"state\")) {\n      const o = _(e, \"state\", {}),\n        s = _(n, \"state\", {});\n      o.type !== s.type && t.setType(s.type), o.behaviors !== s.behaviors && (o.behaviors && t.behaviors.disable(o.behaviors), s.behaviors && t.behaviors.enable(s.behaviors)), s.zoom && o.zoom !== s.zoom && t.setZoom(s.zoom), s.center && o.center !== s.center && t.setCenter(s.center), s.bounds && o.bounds !== s.bounds && t.setBounds(s.bounds);\n    }\n    if (C(n, \"options\")) {\n      const o = _(e, \"options\"),\n        s = _(n, \"options\", {});\n      o !== s && t.options.set(s);\n    }\n    _(e, \"width\") === _(n, \"width\") && _(e, \"height\") === _(n, \"height\") || t.container.fitToViewport(), g(t, r, o), R(a, s, t);\n  }\n  static unmountObject(t, e) {\n    const {\n      instanceRef: n,\n      _events: o\n    } = v(e);\n    null !== t && (Object.keys(o).forEach(e => O(t, e, o[e])), t.destroy(), R(n));\n  }\n}\nconst k = x(d(M, !0, [\"Map\"]));\nk.defaultProps = {\n  width: 320,\n  height: 240\n};\nclass S extends t.Component {\n  constructor() {\n    super(), this.state = {\n      instance: null\n    }, this._parentElement = null, this._getRef = t => {\n      this._parentElement = t;\n    };\n  }\n  componentDidMount() {\n    this._mounted = !0, this.props.ymaps.panorama.isSupported() && S.mountObject(this._parentElement, this.props.ymaps.panorama, this.props).then(t => this._mounted && this.setState({\n      instance: t\n    }));\n  }\n  componentDidUpdate(t) {\n    null !== this.state.instance && S.updateObject(this.state.instance, t, this.props);\n  }\n  componentWillUnmount() {\n    this._mounted = !1, S.unmountObject(this.state.instance, this.props);\n  }\n  render() {\n    const e = w(this.props); /*#__PURE__*/\n    return t.createElement(\"div\", r({\n      ref: this._getRef\n    }, e));\n  }\n  static mountObject(t, e, n) {\n    const {\n        instanceRef: o,\n        _events: s\n      } = v(n),\n      r = _(n, \"point\"),\n      a = _(n, \"locateOptions\"),\n      i = _(n, \"options\");\n    return new Promise((n, c) => {\n      e.locate(r, a).done(r => {\n        if (r.length > 0) {\n          const a = new e.Player(t, r[0], i);\n          R(null, o, a), Object.keys(s).forEach(t => j(a, t, s[t])), n(a);\n        }\n      }, c);\n    });\n  }\n  static updateObject(t, e, n) {\n    const {\n        _events: o,\n        instanceRef: s\n      } = v(n),\n      {\n        _events: r,\n        instanceRef: a\n      } = v(e);\n    if (C(n, \"options\")) {\n      const o = _(e, \"options\"),\n        s = _(n, \"options\");\n      o !== s && t.options.set(s);\n    }\n    if (C(n, \"point\")) {\n      const o = _(n, \"point\"),\n        s = _(e, \"point\"),\n        r = _(n, \"locateOptions\");\n      o !== s && t.moveTo(o, r);\n    }\n    g(t, r, o), R(a, s, t);\n  }\n  static unmountObject(t, e) {\n    const {\n      instanceRef: n,\n      _events: o\n    } = v(e);\n    null !== t && (Object.keys(o).forEach(e => O(t, e, o[e])), R(n));\n  }\n}\nconst T = x(d(S, !0, [\"panorama.isSupported\", \"panorama.locate\", \"panorama.createPlayer\", \"panorama.Player\"]));\nT.defaultProps = {\n  width: 320,\n  height: 240\n};\nclass U extends t.Component {\n  constructor() {\n    super(), this.state = {\n      instance: null\n    }, this.instance = null;\n  }\n  componentDidMount() {\n    const t = U.mountControl(this.props.ymaps.control[this.props.name], this.props);\n    this.instance = t, this.setState({\n      instance: t\n    });\n  }\n  componentDidUpdate(t) {\n    null !== this.instance && U.updateControl(this.instance, t, this.props);\n  }\n  componentWillUnmount() {\n    U.unmountControl(this.instance, this.props);\n  }\n  render() {\n    /*#__PURE__*/return t.createElement(c.Provider, {\n      value: this.state.instance\n    }, this.props.children);\n  }\n  static mountControl(t, e) {\n    const {\n        instanceRef: n,\n        parent: o,\n        lazy: s,\n        _events: r\n      } = v(e),\n      a = new t({\n        data: _(e, \"data\"),\n        options: _(e, \"options\"),\n        state: _(e, \"state\"),\n        mapTypes: _(e, \"mapTypes\"),\n        lazy: s\n      });\n    if (Object.keys(r).forEach(t => j(a, t, r[t])), o && o.controls && \"function\" == typeof o.controls.add) o.controls.add(a);else {\n      if (!o || !o.add || \"function\" != typeof o.add) throw new Error(`No parent found to mount ${e.name}`);\n      o.add(a);\n    }\n    return R(null, n, a), a;\n  }\n  static updateControl(t, e, n) {\n    const {\n        _events: o,\n        instanceRef: s\n      } = v(n),\n      {\n        _events: r,\n        instanceRef: a\n      } = v(e);\n    if (C(n, \"options\")) {\n      const o = _(e, \"options\"),\n        s = _(n, \"options\");\n      o !== s && t.options.set(s);\n    }\n    if (C(n, \"data\")) {\n      const o = _(e, \"data\"),\n        s = _(n, \"data\");\n      o !== s && t.data.set(s);\n    }\n    if (C(n, \"state\")) {\n      const o = _(e, \"state\"),\n        s = _(n, \"state\");\n      o !== s && t.state.set(s);\n    }\n    if (C(n, \"mapTypes\")) {\n      const o = _(e, \"mapTypes\"),\n        s = _(n, \"mapTypes\");\n      o !== s && (t.removeAllMapTypes(), s.forEach(e => t.addMapType(e)));\n    }\n    g(t, r, o), R(a, s, t);\n  }\n  static unmountControl(t, e) {\n    const {\n      instanceRef: n,\n      parent: o,\n      _events: s\n    } = v(e);\n    null !== t && (Object.keys(s).forEach(e => O(t, e, s[e])), o.controls && \"function\" == typeof o.controls.remove ? o.controls.remove(t) : o.remove && \"function\" == typeof o.remove && o.remove(t), R(n));\n  }\n}\nvar D = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"Button\"\n  })), !0, [\"control.Button\"]))),\n  B = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"FullscreenControl\"\n  })), !0, [\"control.FullscreenControl\"]))),\n  A = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"GeolocationControl\"\n  })), !0, [\"control.GeolocationControl\"]))),\n  L = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"ListBox\"\n  })), !0, [\"control.ListBox\"]))),\n  $ = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"ListBoxItem\"\n  })), !0, [\"control.ListBoxItem\"]))),\n  N = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"RouteButton\"\n  })), !0, [\"control.RouteButton\"]))),\n  Z = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"RouteEditor\"\n  })), !0, [\"control.RouteEditor\"]))),\n  z = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"RoutePanel\"\n  })), !0, [\"control.RoutePanel\"]))),\n  G = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"RulerControl\"\n  })), !0, [\"control.RulerControl\"]))),\n  I = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"SearchControl\"\n  })), !0, [\"control.SearchControl\"]))),\n  W = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"TrafficControl\"\n  })), !0, [\"control.TrafficControl\"]))),\n  F = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"TypeSelector\"\n  })), !0, [\"control.TypeSelector\"]))),\n  q = x(l(d(e => /*#__PURE__*/t.createElement(U, r({}, e, {\n    name: \"ZoomControl\"\n  })), !0, [\"control.ZoomControl\"])));\nclass Y extends t.Component {\n  constructor() {\n    super(), this.state = {\n      instance: null\n    }, this.instance = null;\n  }\n  componentDidMount() {\n    const t = Y.mountObject(this.props.ymaps.Clusterer, this.props);\n    this.instance = t, this.setState({\n      instance: t\n    });\n  }\n  componentDidUpdate(t) {\n    null !== this.state.instance && Y.updateObject(this.instance, t, this.props);\n  }\n  componentWillUnmount() {\n    Y.unmountObject(this.instance, this.props);\n  }\n  render() {\n    /*#__PURE__*/return t.createElement(c.Provider, {\n      value: this.state.instance\n    }, this.props.children);\n  }\n  static mountObject(t, e) {\n    const {\n        instanceRef: n,\n        parent: o,\n        _events: s\n      } = v(e),\n      r = new t(_(e, \"options\"));\n    if (Object.keys(s).forEach(t => j(r, t, s[t])), o.geoObjects && \"function\" == typeof o.geoObjects.add) o.geoObjects.add(r);else {\n      if (!o.add || \"function\" != typeof o.add) throw new Error(\"No parent found to mount Clusterer\");\n      o.add(r);\n    }\n    return R(null, n, r), r;\n  }\n  static updateObject(t, e, n) {\n    const {\n        _events: o,\n        instanceRef: s\n      } = v(n),\n      {\n        _events: r,\n        instanceRef: a\n      } = v(e);\n    if (C(n, \"options\")) {\n      const o = _(e, \"options\"),\n        s = _(n, \"options\");\n      o !== s && t.options.set(s);\n    }\n    g(t, r, o), R(a, s, t);\n  }\n  static unmountObject(t, e) {\n    const {\n      instanceRef: n,\n      parent: o,\n      _events: s\n    } = v(e);\n    null !== t && (Object.keys(s).forEach(e => O(t, e, s[e])), o.geoObjects && \"function\" == typeof o.geoObjects.remove ? o.geoObjects.remove(t) : o.remove && \"function\" == typeof o.remove && o.remove(t), R(n));\n  }\n}\nvar V = x(l(d(Y, !0, [\"Clusterer\"])));\nclass H extends t.Component {\n  constructor() {\n    super(), this.state = {\n      instance: null\n    };\n  }\n  componentDidMount() {\n    const t = H.mountObject(this.props.ymaps.ObjectManager, this.props);\n    this.instance = t, this.setState({\n      instance: t\n    });\n  }\n  componentDidUpdate(t) {\n    null !== this.instance && H.updateObject(this.instance, t, this.props);\n  }\n  componentWillUnmount() {\n    H.unmountObject(this.instance, this.props);\n  }\n  render() {\n    return null;\n  }\n  static mountObject(t, e) {\n    const {\n        instanceRef: n,\n        parent: o,\n        _events: s\n      } = v(e),\n      r = _(e, \"options\", {}),\n      a = _(e, \"features\", {}),\n      i = _(e, \"filter\", null),\n      c = _(e, \"objects\", {}),\n      l = _(e, \"clusters\", {}),\n      p = new t(r);\n    if (p.add(a || []), p.setFilter(i), p.objects.options.set(c), p.clusters.options.set(l), Object.keys(s).forEach(t => j(p, t, s[t])), o.geoObjects && \"function\" == typeof o.geoObjects.add) o.geoObjects.add(p);else {\n      if (!o.add || \"function\" != typeof o.add) throw new Error(\"No parent found to mount ObjectManager\");\n      o.add(p);\n    }\n    return R(null, n, p), p;\n  }\n  static updateObject(t, e, n) {\n    const {\n        _events: o,\n        instanceRef: s\n      } = v(n),\n      {\n        _events: r,\n        instanceRef: a\n      } = v(e);\n    if (C(n, \"options\")) {\n      const o = _(e, \"options\"),\n        s = _(n, \"options\");\n      o !== s && t.options.set(s);\n    }\n    if (C(n, \"objects\")) {\n      const o = _(e, \"objects\"),\n        s = _(n, \"objects\");\n      o !== s && t.objects.options.set(s);\n    }\n    if (C(n, \"clusters\")) {\n      const o = _(e, \"clusters\"),\n        s = _(n, \"clusters\");\n      o !== s && t.clusters.options.set(s);\n    }\n    if (C(n, \"filter\")) {\n      const o = _(e, \"filter\"),\n        s = _(n, \"filter\");\n      o !== s && t.setFilter(s);\n    }\n    if (C(n, \"features\")) {\n      const o = _(e, \"features\"),\n        s = _(n, \"features\");\n      o !== s && (t.remove(o), t.add(s));\n    }\n    g(t, r, o), R(a, s, t);\n  }\n  static unmountObject(t, e) {\n    const {\n      instanceRef: n,\n      parent: o,\n      _events: s\n    } = v(e);\n    null !== t && (Object.keys(s).forEach(e => O(t, e, s[e])), o.geoObjects && \"function\" == typeof o.geoObjects.remove ? o.geoObjects.remove(t) : o.remove && \"function\" == typeof o.remove && o.remove(t), R(n));\n  }\n}\nvar J = x(l(d(H, !0, [\"ObjectManager\"])));\nclass K extends t.Component {\n  constructor() {\n    super(), this.state = {\n      instance: null\n    }, this.instance = null;\n  }\n  componentDidMount() {\n    const {\n        name: t,\n        ymaps: e,\n        dangerZone: n\n      } = this.props,\n      o = K.mountObject(n && \"function\" == typeof n.modifyConstructor ? n.modifyConstructor(e[t]) : e[t], this.props);\n    this.instance = o, this.setState({\n      instance: o\n    });\n  }\n  componentDidUpdate(t) {\n    null !== this.instance && K.updateObject(this.instance, t, this.props);\n  }\n  componentWillUnmount() {\n    K.unmountObject(this.instance, this.props);\n  }\n  render() {\n    return null;\n  }\n  static mountObject(t, e) {\n    const {\n        instanceRef: n,\n        parent: o,\n        _events: s\n      } = v(e),\n      r = new t(_(e, \"geometry\"), _(e, \"properties\"), _(e, \"options\"));\n    if (Object.keys(s).forEach(t => j(r, t, s[t])), o && o.geoObjects && \"function\" == typeof o.geoObjects.add) o.geoObjects.add(r);else {\n      if (!o || !o.add || \"function\" != typeof o.add) throw new Error(`No parent found to mount ${e.name}`);\n      o.add(r);\n    }\n    return R(null, n, r), r;\n  }\n  static updateObject(t, e, n) {\n    const {\n        _events: o,\n        instanceRef: s\n      } = v(n),\n      {\n        _events: r,\n        instanceRef: a\n      } = v(e);\n    if (C(n, \"geometry\")) {\n      const o = _(e, \"geometry\", {}),\n        s = _(n, \"geometry\", {});\n      Array.isArray(s) && s !== o ? Array.isArray(s[0]) && \"number\" == typeof s[1] ? (t.geometry.setCoordinates(s[0]), t.geometry.setRadius(s[1])) : t.geometry.setCoordinates(s) : \"object\" == typeof s && (s.coordinates !== o.coordinates && t.geometry.setCoordinates(s.coordinates), s.radius !== o.radius && t.geometry.setRadius(s.radius));\n    }\n    if (C(n, \"properties\")) {\n      const o = _(e, \"properties\"),\n        s = _(n, \"properties\");\n      o !== s && t.properties.set(s);\n    }\n    if (C(n, \"options\")) {\n      const o = _(e, \"options\"),\n        s = _(n, \"options\");\n      o !== s && t.options.set(s);\n    }\n    g(t, r, o), R(a, s, t);\n  }\n  static unmountObject(t, e) {\n    const {\n      instanceRef: n,\n      parent: o,\n      _events: s\n    } = v(e);\n    null !== t && (Object.keys(s).forEach(e => O(t, e, s[e])), o.geoObjects && \"function\" == typeof o.geoObjects.remove ? o.geoObjects.remove(t) : o.remove && \"function\" == typeof o.remove && o.remove(t), R(n));\n  }\n}\nconst Q = {\n  modifyConstructor(t) {\n    function e(e, n, o) {\n      t.call(this, {\n        geometry: e,\n        properties: n\n      }, o);\n    }\n    return e.prototype = t.prototype, e;\n  }\n};\nvar X = x(l(d(e => /*#__PURE__*/t.createElement(K, r({}, e, {\n    name: \"GeoObject\",\n    dangerZone: Q\n  })), !0, [\"GeoObject\"]))),\n  tt = x(l(d(e => /*#__PURE__*/t.createElement(K, r({}, e, {\n    name: \"Circle\"\n  })), !0, [\"Circle\"]))),\n  et = x(l(d(e => /*#__PURE__*/t.createElement(K, r({}, e, {\n    name: \"Placemark\"\n  })), !0, [\"Placemark\"]))),\n  nt = x(l(d(e => /*#__PURE__*/t.createElement(K, r({}, e, {\n    name: \"Polygon\"\n  })), !0, [\"Polygon\"]))),\n  ot = x(l(d(e => /*#__PURE__*/t.createElement(K, r({}, e, {\n    name: \"Polyline\"\n  })), !0, [\"Polyline\"]))),\n  st = x(l(d(e => /*#__PURE__*/t.createElement(K, r({}, e, {\n    name: \"Rectangle\"\n  })), !0, [\"Rectangle\"])));\nexport { D as Button, tt as Circle, V as Clusterer, B as FullscreenControl, X as GeoObject, A as GeolocationControl, L as ListBox, $ as ListBoxItem, k as Map, J as ObjectManager, T as Panorama, et as Placemark, nt as Polygon, ot as Polyline, st as Rectangle, N as RouteButton, Z as RouteEditor, z as RoutePanel, G as RulerControl, I as SearchControl, W as TrafficControl, F as TypeSelector, y as YMaps, q as ZoomControl, p as useYMaps, d as withYMaps };\n//# sourceMappingURL=react-yandex-maps.esm.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}